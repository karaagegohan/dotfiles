[[plugins]]
repo = 'itchyny/lightline.vim' # {{{
hook_add = '''

    let g:lightline = {
        \ 'colorscheme': 'wombat',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [
        \     ['mode', 'paste'],
        \     ['fugitive', 'gitgutter', 'filename'],
        \   ],
        \   'right': [
        \     ['lineinfo'],
        \     ['percent'],
        \     ['nextbuffername', 'fileformat', 'fileencoding', 'filetype'],
        \   ]
        \ },
        \ 'component_function': {
        \   'modified': 'MyModified',
        \   'time': 'MyTime',
        \   'readonly': 'MyReadonly',
        \   'fugitive': 'MyFugitive',
        \   'filename': 'MyFilename',
        \   'fileformat': 'MyFileformat',
        \   'filetype': 'MyFiletype',
        \   'fileencoding': 'MyFileencoding',
        \   'mode': 'MyMode',
        \   'syntastic': 'SyntasticStatuslineFlag',
        \   'charcode': 'MyCharCode',
        \   'gitgutter': 'MyGitGutter',
        \   'nextbuffername': 'MyNextBufferName',
        \ },
        \ 'separator': {'left': '', 'right': ''},
        \ 'subseparator': {'left': '|', 'right': '|'}
        \ }
    if g:env#mac
      let g:lightline['separator'] = {'left': '⮀', 'right': '⮂'}
      let g:lightline['subseparator'] = {'left': '⮁', 'right': '⮃'}
    endif

    function! MyModified() "{{{
        return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction "}}}

    function! MyTime() "{{{
        return winwidth('.') > 110 ? strftime("%Y/%m/%d %H:%M:%S", localtime()) : (winwidth('.') > 90 ? strftime("%Y/%m/%d", localtime()) : '')
    endfunction "}}}

    function! MyReadonly() "{{{
        return &ft !~? 'help\|vimfiler\|gundo' && &ro ? '-' : ''
    endfunction "}}}

    function! MyFilename() "{{{
        return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
            \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
            \  &ft == 'unite' ? unite#get_status_string() :
            \  &ft == 'vimshell' ? substitute(b:vimshell.current_dir,expand('~'),'~','') :
            \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
            \ ('' != MyModified() ? ' ' . MyModified() : '')
    endfunction "}}}

    function! MyFugitive() "{{{
        try
            if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
                let _ = fugitive#head()
                return strlen(_) ? _ : ''
            endif

        catch
        endtry
        return ''
    endfunction "}}}

    function! MyFileformat() "{{{
        return winwidth('.') > 70 ? &fileformat : ''
    endfunction "}}}

    function! MyFiletype() "{{{
        return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
    endfunction "}}}

    function! MyFileencoding() "{{{
        return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
    endfunction "}}}

    function! MyMode() "{{{
        return winwidth('.') > 60 ? lightline#mode() : ''
    endfunction "}}}

    function! MyGitGutter() "{{{
        if ! exists('*GitGutterGetHunkSummary')
            \ || ! get(g:, 'gitgutter_enabled', 0)
            \ || winwidth('.') <= 90
            return ''
        endif
        let symbols = [
            \  g:gitgutter_sign_added,
            \  g:gitgutter_sign_modified,
            \  g:gitgutter_sign_removed
            \ ]
        let hunks = GitGutterGetHunkSummary()
        let ret = []
        for i in [0, 1, 2]
            if hunks[i] > 0
                call add(ret, symbols[i] . hunks[i])
            endif
        endfor
        return join(ret, ' ')
    endfunction "}}}

    function! MyCharCode() "{{{
    " https://github.com/Lokaltog/vim-powerline/blob/develop/autoload/Powerline/Functions.vim
        if winwidth('.') <= 70
            return ''
        endif

        " Get the output of :ascii
        redir => ascii
        silent! ascii
        redir END

        if match(ascii, 'NUL') != -1
            return 'NUL'
        endif

        " Zero pad hex values
        let nrformat = '0x%02x'

        let encoding = (&fenc == '' ? &enc : &fenc)

        if encoding == 'utf-8'
            " Zero pad with 4 zeroes in unicode files
            let nrformat = '0x%04x'
        endif

        " Get the character and the numeric value from the return value of :ascii
        " This matches the two first pieces of the return value, e.g.
        " "<F>  70" => char: 'F', nr: '70'
        let [str, char, nr; rest] = matchlist(ascii, '\v\<(.{-1,})\>\s*([0-9]+)')

        " Format the numeric value
        let nr = printf(nrformat, nr)

        return "'". char ."' ". nr
    endfunction "}}}

    function! MyNextBufferName() abort "{{{
        try
            redir => ls
            silent! ls
            redir END
            let s:cur_index = 0
            let s:buffers = split(ls, '\n')
            for s:buffer in s:buffers
                if match(s:buffer, '%a') != -1
                    break
                endif
                let s:cur_index = s:cur_index + 1
            endfor
            let s:max_index = len(s:buffers) - 1
            let s:nex_index = s:cur_index + 1
            if s:nex_index == s:max_index + 1
                let s:nex_index = 0
            endif
            let s:pre_index = s:cur_index - 1
            if s:pre_index == -1
                let s:pre_index = s:max_index
            endif
            let s:pre_name = matchstr(s:buffers[s:pre_index], '"\zs.*\ze"')
            let s:pre_name = fnamemodify(s:pre_name, ":t")
            let s:nex_name = matchstr(s:buffers[s:nex_index], '"\zs.*\ze"')
            let s:nex_name = fnamemodify(s:nex_name, ":t")
            let s:str_length = 10
            return '( ' . s:pre_name[0:s:str_length] . ' <=|=> ' . s:nex_name[0:s:str_length] . ' )'
        catch
        endtry
    endfunction "}}}

    function! MyNextBufferName() "{{{
      function! s:file_pass_filter(files)
        let l:ret = []
        for l:file  in a:files
          if !isdirectory(l:file)
            call add(l:ret, l:file)
          endif
        endfor
        return l:ret
      endfunction
      let l:current_file = expand('%:p') 
      let l:files = s:file_pass_filter(split(glob(expand('%:p:h') . "/*"), "\n"))
      if len(l:files) <= 1
        return ""
      endif
      let l:cnt = match(l:files, l:current_file)
      let l:next = fnamemodify(l:files[(l:cnt + 1) % len(l:files)], ":t")
      let l:prev = fnamemodify(l:files[(l:cnt - 1) % len(l:files)], ":t")
      return l:next . " : " . l:prev"
    endfunction "}}}

'''
# }}}

[[plugins]]
repo = 'kien/rainbow_parentheses.vim' # {{{
hook_add = '''

    " color
    let g:rbpt_colorpairs = [
        \ ['brown',       'RoyalBlue3'],
        \ ['Darkblue',    'SeaGreen3'],
        \ ['darkgray',    'DarkOrchid3'],
        \ ['darkgreen',   'firebrick3'],
        \ ['darkcyan',    'RoyalBlue3'],
        \ ['darkred',     'SeaGreen3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['brown',       'firebrick3'],
        \ ['gray',        'RoyalBlue3'],
        \ ['black',       'SeaGreen3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['Darkblue',    'firebrick3'],
        \ ['darkgreen',   'RoyalBlue3'],
        \ ['darkcyan',    'SeaGreen3'],
        \ ['darkred',     'DarkOrchid3'],
        \ ['red',         'firebrick3'],
        \ ]

    let g:rbpt_max            = 16
    let g:rbpt_loadcmd_toggle = 0

    autocmd vimrc ColorScheme * RainbowParenthesesToggle
    autocmd vimrc ColorScheme * RainbowParenthesesLoadRound
    autocmd vimrc ColorScheme * RainbowParenthesesLoadSquare
    autocmd vimrc ColorScheme * RainbowParenthesesLoadBraces
    autocmd vimrc ColorScheme * RainbowParenthesesLoadChevrons

'''
# }}}

[[plugins]]
repo = 'thinca/vim-fontzoom' # {{{
if = '''has('gui')'''
hook_add = '''

    " key_mappings {{{
    nmap <RIGHT> <Plug>(fontzoom-larger)
    nmap <LEFT>  <Plug>(fontzoom-smaller)
    "}}}

'''
# }}}

[[plugins]]
repo = 'thinca/vim-splash'# {{{
if = '''0'''
# }}}

[[plugins]]
repo = 'Yggdroot/indentLine'# {{{
hook_add = '''

    " for tab
    set list listchars=tab:\¦\ 

    " color for vim
    let g:indentLine_color_term = 239

    " color for Gvim
    let g:indentLine_color_gui = '#A4E57E'

    " none X terminal
    let g:indentLine_color_tty_light = 7 " (default: 4)
    let g:indentLine_color_dark = 1 " (default: 2)

    " let g:indentLine_char = 'c'

'''
# }}}

